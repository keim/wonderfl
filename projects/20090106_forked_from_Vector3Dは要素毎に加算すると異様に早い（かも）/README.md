# [forked from: Vector3Dは要素毎に加算すると異様に早い（かも）](http://fl.corge.net/c/ycJM)

favorite:1 / forked:0

同じ長さ、値のArray,Vector,Vector3Dをaddと同じ処理を100万回実行した時の処理時間（ミリ/秒）  
その２  
MacBookPro2.4Gh,OSX 10.5.6  
Array0:348//前回と同じ  
Array1:320//決め打  
Vector0:85//前回と同じ  
Vector1:80//決め打  
Vector3D0:623//前回と同じ  
Vector3D1:17//要素毎に加算  
Vector3D2:656//addの代わりの関数を作った  
Vector3D3:625//addの代わりの関数を作った2  
null:6//Vector3Dをnewしてforでまわすだけ。  
  
Vector3Dを要素毎に加算すると異様に早い。  
けど、早すぎてちょっと信じられない感じ。  
いろいろ検証が必要。  
  
add以外にもいろいろ試してみるといいかも。  
  
  
 --------------------------------------------------------  
<fork元より>  
->Array が Vector より非常に遅いのは，たぶん確定．  
->関数呼出 と new が非常に遅いのも，たぶん確定．  
->ループによるインデックス呼出とループ展開ではあまり差が無い可能性（×確定）．  
  
<Vector3D0とVector3D1について>  
->メンバアクセスよりインデックスアクセスの方が遅い？  
（クラス宣言による固定インデックスでのアクセスの方が，変数インデックスでのアクセスより最適化しやすい  
->確かこれってAS3のAdobeの発表資料に書いてあった気がするな．未確認）  
->ローカルで確保したVectorとVector3Dのメモリ空間の違い？  
（_v0c:Vectorはヒープ，_v3c:Vector3Dはスタック上に確保される形で最適化されてる可能性  
->関数の外で参照されないインスタンスをスタック上に展開するのは割と良くある最適化手法．）  
->VectorとVector3Dでキャッシュヒット率が違う  
（一般論．VectorもVector3Dも整然と固まってるだろうし，ループで回す分には同じ気がするけど．．．  
->というか，fork元のルーチンだと同じ位置に100万回アクセスしてるので，今回の差には影響してないはず）  
->素直に１００万個のVector x 3で計算す

![thumbnail](./thumbnail.jpg)
